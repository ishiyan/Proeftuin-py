// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates `currencies.go` and `currencies_test.go`, overwriting any existing versions.
// It should be invoked by running `go generate` in this directory.
// It reads currency data from the `currencies.csv` file.

package main

import (
	"bytes"
	"encoding/csv"
	"errors"
	"fmt"
	"go/format"
	"io"
	"os"
	"strconv"
	"strings"
	"time"
)

type currency struct {
	code        string
	decimals    int
	symbol      string
	description string
}

var errInvalidLine = errors.New("invalid input CSV line")

func main() {
	cs, err := read("currencies.csv")
	if err != nil {
		die(err)
	}

	printCurrencyPython("currencies.py", cs)
}

func read(filename string) ([]currency, error) {
	currencies := []currency{}

	f, err := os.Open(filename)
	if err != nil {
		return currencies, fmt.Errorf("opening currencies: %w", err)
	}
	defer f.Close()

	r := csv.NewReader(f)
	r.Comma = '|'
	r.Comment = '#'
	r.FieldsPerRecord = 4
	r.ReuseRecord = false
	r.TrimLeadingSpace = true

	ln := 0

	for {
		record, err := r.Read()
		if errors.Is(err, io.EOF) {
			break
		}

		ln++
		if err != nil {
			return currencies, fmt.Errorf("line %v: error reading: %w", ln, err)
		}

		c, err := parse(record, ln)
		if err != nil {
			return currencies, err
		}

		currencies = append(currencies, *c)
	}

	return currencies, nil
}

func parse(record []string, ln int) (*currency, error) {
	code := strings.TrimSpace(record[0])
	if len(code) != 3 { //nolint:gomnd
		return nil, fmt.Errorf(
			"line %v: currency code should have 3 characters, got '%v': %w", ln, code, errInvalidLine)
	}

	d := strings.TrimSpace(record[1])
	if len(d) < 1 {
		return nil, fmt.Errorf(
			"line %v: number of decimals should not be empty, got '%v': %w", ln, d, errInvalidLine)
	}

	dec, err := strconv.Atoi(d)
	if err != nil {
		return nil, fmt.Errorf(
			"line %v: number of decimals should be an integer, got '%v': %w", ln, d, errInvalidLine)
	}

	if dec < 0 {
		return nil, fmt.Errorf(
			"line %v: number of decimals should be a positive integer, got '%v': %w", ln, d, errInvalidLine)
	}

	symbol := strings.TrimSpace(record[2])
	descr := strings.TrimSpace(record[3])

	if len(descr) < 1 {
		return nil, fmt.Errorf("line %v: description should not be empty: %w", ln, errInvalidLine)
	}

	return &currency{code, dec, symbol, descr}, nil
}

func die(err error) {
	fmt.Println(err) //nolint:forbidigo
	os.Exit(1)
}

func printf(w io.Writer, format string, a ...interface{}) {
	_, err := fmt.Fprintf(w, format, a...)
	if err != nil {
		die(err)
	}
}

func minmaxdecimals(cs []currency) (int, int) {
	min := 999
	max := -999 //nolint:gomnd

	for _, c := range cs {
		if c.decimals > max {
			max = c.decimals
		}

		if c.decimals < min {
			min = c.decimals
		}
	}

	return min, max
}

func codes(cs []currency, n int) string {
	first := true
	s := ""

	for _, c := range cs {
		if c.decimals == n {
			if first {
				first = false
			} else {
				s += ", "
			}

			s += c.code
		}
	}

	return s
}

func printBuffer(b *bytes.Buffer, filename string, formatSource bool) {
	f, err := os.Create(filename)
	if err != nil {
		die(err)
	}
	defer f.Close()

	if formatSource {
		data, err := format.Source(b.Bytes())
		if err != nil {
			die(err)
		}

		_, err = f.Write(data)
		if err != nil {
			die(err)
		}
	} else {
		_, err = f.Write(b.Bytes())
		if err != nil {
			die(err)
		}
	}
}

//nolint:funlen,cyclop
func printCurrencyPython(filename string, cs []currency) {
	var b bytes.Buffer

	printf(&b, "# Code generated by 'go run generate_currencies_python.go'; DO NOT EDIT.\n")
	printf(&b, "# %v\n\n", time.Now())
	printf(&b, "#\n")
	printf(&b, "# The sources for data:\n")
	printf(&b, "# - [ISO 4217](https://www.currency-iso.org/en/home/tables/table-a1.html)\n")
	printf(&b, "# - [OANDA ISO currency codes](https://www1.oanda.com/currency/iso-currency-codes/)\n")
	printf(&b, "# - [Wikipedia ISO 4217](https://en.wikipedia.org/wiki/ISO_4217)\n")
	printf(&b, "# - [Wikipedia list of cryptocurrencies](https://en.wikipedia.org/wiki/List_of_cryptocurrencies)\n")
	printf(&b, "#\n")
	printf(&b, "# The predefined ISO 4217 three-letter alphabetic currency codes.\n")
	printf(&b, "\n")

	for _, c := range cs {
		printf(&b, "    %v = Currency('%v',%v,'%v','%v')\n", c.code, c.code, c.decimals, c.symbol, c.description)
		printf(&b, "    \"\"\"%v\"\"\"\n", c.description)
	}


	printBuffer(&b, filename, true)
}
